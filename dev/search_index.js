var documenterSearchIndex = {"docs":
[{"location":"api/wrapper.html#Low-Level-API","page":"Low-Level API","title":"Low-Level API","text":"","category":"section"},{"location":"api/wrapper.html","page":"Low-Level API","title":"Low-Level API","text":"Modules = [AcqSynth]\nPages   = [\"wrapper.jl\"]\nOrder   = [:function]\nPrivate = true","category":"page"},{"location":"api/wrapper.html#AcqSynth.clear_setupdone_bit-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.clear_setupdone_bit","text":"clear_setupdone_bit(boardnum)\n\nClear the setupDone flag, forcing the following call to setup_board to perform a full calibration.\n\nExamples\n\njulia> boardnum = 2\njulia> clear_setupdone_bit(boardnum)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_ECL_trigger-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_ECL_trigger","text":"get_ECL_trigger(boardnum)\n\nGet ECL trigger delay state. Returns 1 if the ECL trigger mode is enabled and 0 otherwise.\n\nFunction valid only for AD12 and AD8 boards.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> println(get_ECL_trigger(boardnum,4))\n0\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_ECL_trigger_delay-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_ECL_trigger_delay","text":"get_ECL_trigger_delay(boardnum)\n\nGet ECL trigger delay value.\n\nFunction valid only for AD12 and AD8 boards.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> println(get_ECL_trigger_delay(boardnum,4))\n512\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_adcresolution-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_adcresolution","text":"get_adcresolution(boardnum)\n\nReturn the bit resolution of the ADC on the board.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> println(get_adcresolution(boardnum)) # in bits\n12\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_all_channels-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_all_channels","text":"get_all_channels(boardnum)\n\nReturn the number of available channels on the ADC.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> println(get_all_channels(boardnum))\n2\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_averager-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_averager","text":"get_averager(boardnum)\n\nReturn the averager capture parameters. See set_averager for details.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> (count, depth) = get_averager(boardnum)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_channels-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_channels","text":"get_channels(boardnum)\n\nReturn the current channel setup. See the set_channels function for details.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> get_channels(boardnum) # channels previously set to IN0|IN1\n3\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_clock-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_clock","text":"get_clock(boardnum)\n\nReturn the clock being used, 1 for the internal clock, and 0 for the external clock.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> println(get_clock(boardnum))\n1\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_decimation-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_decimation","text":"get_decimation(boardnum)\n\nReturn the decimation value.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> println(get_decimation(boardnum))\n8\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_frequency-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_frequency","text":"get_frequency(boardnum)\n\nReturn the effective sampling frequency in MHz. This is a rough measurement based on the PCIe reference clock.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> println(get_frequency(boardnum)) # in MHz\n1998\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_memsize-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_memsize","text":"get_memsize(boardnum)\n\nReturn the size of the digitizer's on-board memory in MiB.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> println(get_memsize(boardnum)) # in MiB\n8192\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_num_boards-Tuple{}","page":"Low-Level API","title":"AcqSynth.get_num_boards","text":"get_num_boards()\n\nReturn the number of Ultraview boards connected to the PC.\n\nExamples\n\njulia> get_num_boards()\n1\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_num_channels-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_num_channels","text":"get_num_channels(boardnum)\n\nReturns the number of channels configured for acquisition. Used to help decode buffer data. For example, if two channels are in use, the samples will be arraged by channel first, and then by sample index: [s1_c1, s1_c2, s2_c1, s2_c2...].\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> println(get_num_channels(boardnum))\n1\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_pretrigger_mem-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_pretrigger_mem","text":"get_pretrigger_mem(boardnum)\n\nReturn the number of samples to be recorded prior to the trigger.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> println(get_pretrigger_mem(boardnum))\n128\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_segmented_capture-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_segmented_capture","text":"get_segmented_capture(boardnum)\n\nReturn the segmented capture parameters. See set_segmented_capture for details.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> (count, depth) = get_segmented_capture(boardnum)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_serial-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_serial","text":"get_serial(boardnum)\n\nReturn the serial number of the chosen board.\n\nNote that the DLL function requires \"get_usercode.svf\" to be in the current directory when it is executed.\n\nExamples\n\njulia> boardnum = 0\njulia> get_serial(boardnum)\n1092\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_trigger-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_trigger","text":"get_trigger(boardnum)\n\nReturn the trigger type. Returns 0 for NO_TRIGGER, 1 for WAVEFORM_TRIGGER, 2 for SYNC_SELECTIVE_RECORDING, 3 for HETERODYNE or 4 for TTL_TRIGGER_EDGE.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> println(get_trigger(boardnum))\n1\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.get_waveform_trigger_params-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.get_waveform_trigger_params","text":"get_waveform_trigger_params(boardnum)\n\nReturn the current waveform trigger threshold and hysteresis values.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> (threshold, hysteresis) = get_waveform_trigger_params(boardnum)\njulia> println(\"treshold: $threshold, hysteresis: $hysteresis\")\ntreshold: 2048, hysteresis: 512\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.has_microsynth-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.has_microsynth","text":"has_microsynth(boardnum)\n\nReturn true if the board has a microsynth, false otherwise. If the board does have a microsynth, it can be used to program the frequency of the ADC.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> has_microsynth(boardnum)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.is_AD12-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.is_AD12","text":"is_AD12(boardnum)\n\nReturn true if the board is a model AD12, false otherwise.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> is_AD12(boardnum)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.is_AD14-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.is_AD14","text":"is_AD14(boardnum)\n\nReturn true if the board is a model AD14, false otherwise.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> is_AD14(boardnum)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.is_AD16-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.is_AD16","text":"is_AD16(boardnum)\n\nReturn true if the board is a model AD16, false otherwise.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> is_AD16(boardnum)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.mem_alloc-Tuple{}","page":"Low-Level API","title":"AcqSynth.mem_alloc","text":"mem_alloc()\n\nAllocate a 1 MiB (2^20 bytes) block of DMA page aligned memory.\n\nExamples\n\njulia> block = mem_alloc()\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.mem_free-Tuple{Array{UInt8,1}}","page":"Low-Level API","title":"AcqSynth.mem_free","text":"mem_free(block)\n\nFree the memory block allocated by mem_alloc. Note that the variable used to reference to the block should be assigned to something else for safety.\n\nExamples\n\njulia> mem_free(block)\njulia> block = 0\n0\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.mem_read-Tuple{Int64,Array{UInt8,1}}","page":"Low-Level API","title":"AcqSynth.mem_read","text":"mem_read(boardnum, block)\n\nRead 1 block of data into a buffer previously allocated by the mem_alloc function and clears it from the board memory. Call mem_read repeatedly to transfer all the blocks that were acquired.\n\nExamples\n\njulia> boardnum = 2\njulia> block = mem_alloc()\njulia> mem_read(boardnum,block)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.set_ECL_trigger-Tuple{Int64,Int64}","page":"Low-Level API","title":"AcqSynth.set_ECL_trigger","text":"set_ECL_trigger(boardnum, state)\n\nEnable (or disable) ECL trigger mode. Setting state to 1 enables the ECL trigger, 0 disables it. The board will be forced into reset, awaiting an external trigger.\n\nFunction valid only for AD12 and AD8 boards.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> set_ECL_trigger(boardnum,1)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.set_ECL_trigger_delay-Tuple{Int64,Int64}","page":"Low-Level API","title":"AcqSynth.set_ECL_trigger_delay","text":"set_ECL_trigger_delay(boardnum, delay)\n\nSets a delay after the ECL trigger goes from zero to one before data begins acquiring. delay should be the delay in DCLK cycles (ADC outputs data in four 12-bit words/DCLK cycle). In single channel mode there are 4 samples per DCLK. In two channel mode, there are 2 samples per DCLK.\n\nFunction valid only for AD12 and AD8 boards.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> set_ECL_trigger_delay(boardnum,4)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.set_averager-Tuple{Int64,Int64,Int64}","page":"Low-Level API","title":"AcqSynth.set_averager","text":"set_averager(boardnum, count, depth)\n\nConfigure the board for averaging operation. Note that segmented capture will be disabled. Set count to 0 to disable averaging. Enabling the averager changes the output data format to 32-bit samples.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nArguments\n\nboardnum::Integer: index of installed board\ncount::Integer: number (0 to 2^16-1) of segments to average over. Each   segment's starting amplitude is determined by the currently configured   trigger. Set count to 0 to disable averaging or to 1 for flow through.\ndepth::Integer: number of samples to acquire in each   segment, must be a multiple of 16.\n\nExamples\n\njulia> boardnum = 2\njulia> count = 2 # number of segments to average over\njulia> depth = 1100 # number of samples per segment\njulia> set_averager(boardnum,count,depth)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.set_channels-Tuple{Int64,Int64}","page":"Low-Level API","title":"AcqSynth.set_channels","text":"set_channels(boardnum, chan_select)\n\nConfigure which channels to use for acquisition.\n\nFor AD14 or AD16 boards, chan_select should be the bitwise OR of the desired channels IN0, IN1, IN2, and IN3.\n\nFor AD12 boards, select either the bitwise OR of the desired channels AIN0 and AIN1, or DESCLKIQ for DESCLKIQ mode, or DESIQ for DESIQ mode.\n\nIn DESCLKIQ mode, the I- and Q- inputs remain electrically separate, increasing input bandwidth. In DESIQ, the I- and Q- inputs are shorted together. In either of these modes, both inputs must be externally driven.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> chan_select = IN0|IN1\njulia> set_channels(boardnum,chan_select)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.set_clock-Tuple{Int64,Int64}","page":"Low-Level API","title":"AcqSynth.set_clock","text":"set_clock(boardnum,chan_select)\n\nConfigure whether to use the CLOCK_INTERNAL (1), or CLOCK_EXTERNAL (0).\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> set_clock(boardnum,CLOCK_INTERNAL)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.set_decimation-Tuple{Int64,Int64}","page":"Low-Level API","title":"AcqSynth.set_decimation","text":"set_decimation(boardnum, deci_value)\n\nSet ADC decimation (return a sample every deci_value samples only). deci_value should be 1, 2, 4 or 8. A value of 1 disables decimation.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> set_decimation(boardnum,8)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.set_pretrigger_mem-Tuple{Int64,Int64}","page":"Low-Level API","title":"AcqSynth.set_pretrigger_mem","text":"set_pretrigger_mem(boardnum, samples)\n\nSet the number of samples to be recorded prior to the trigger. Can be between 0 and 4095.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> set_pretrigger_mem(boardnum,500)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.set_segmented_capture-Tuple{Int64,Int64,Int64}","page":"Low-Level API","title":"AcqSynth.set_segmented_capture","text":"set_segmented_capture(boardnum, count, depth)\n\nConfigure the board for segmented capture operation. Note that averaging will be disabled. Set count to 0 to disable segmented capture.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nArguments\n\nboardnum::Integer: index of installed board\ncount::Integer: number (0 to 2^32-1) of segments to acquire. Each segment's   starting amplitude is determined by the currently configured trigger. Set   count to 0 to disable segmented capture.\ndepth::Integer: number (0 to 2^32-1) of samples to acquire in each segment.   Note that the last segment will have as many samples as can fit in the rest of   the buffer. Must be a multiple of 16.\n\nExamples\n\njulia> boardnum = 2\njulia> count = 2 # number of segments to acquire\njulia> depth = 1100 # number of samples per segment\njulia> set_segmented_capture(boardnum,count,depth)\n\n\n\n\n\n","category":"method"},{"location":"api/wrapper.html#AcqSynth.set_trigger","page":"Low-Level API","title":"AcqSynth.set_trigger","text":"set_trigger(boardnum, ttype, slope, channel)\n\nSet the trigger type. If a waveform trigger is desired, it must be configured prealably with the [configure_waveform_trigger](@ref) function.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nArguments\n\nboardnum::Integer: index of installed board\nttype::Integer: trigger type, choose between NO_TRIGGER (0),   WAVEFORM_TRIGGER (1), SYNC_SELECTIVE_RECORDING (2), HETERODYNE (3) or   TTL_TRIGGER_EDGE (4).\nslope::Integer: select whether to trigger on a FALLING_EDGE (0) or a   RISING_EDGE (1).\nchannel::Int: channel to trigger on for analog triggering\n\nExamples\n\njulia> boardnum = 2\njulia> ttype = 4 # TTL trigger\njulia> slope = 1 # rising edge\njulia> set_trigger(boardnum,ttype,slope)\n\n\n\n\n\n","category":"function"},{"location":"api/wrapper.html#AcqSynth.set_waveform_trigger_params","page":"Low-Level API","title":"AcqSynth.set_waveform_trigger_params","text":"set_waveform_trigger_params(boardnum, threshold, hysteresis=256)\n\nConfigure waveform triggering parameters. Do not forget to enable triggering with the set_trigger function.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nArguments\n\nboardnum::Integer: index of installed board\nthreshold::Integer: trigger treshold, choose a value between 0 and your ADC   maximum value (eg, 2^16-1 for a 16-bit board).\nhysteresis::Integer: this value should typically be a few times the noise   amplitude of your signal, choose a value between 0 and your ADC maximum value   (eg, 2^16-1 for a 16-bit board).\n\nExamples\n\njulia> boardnum = 2\njulia> threshold = 2^11 # middle value for a 12-bit board\njulia> hysteresis = 512 # estimated noise level * 3\njulia> set_waveform_trigger_params(boardnum,threshold,hysteresis)\njulia> ttype = 1 # waveform trigger\njulia> slope = 1 # rising edge\njulia> channel = IN0 # channel IN0\njulia> set_trigger(boardnum,ttype,slope,channel)\n\n\n\n\n\n","category":"function"},{"location":"api/wrapper.html#AcqSynth.setup_acquire","page":"Low-Level API","title":"AcqSynth.setup_acquire","text":"setup_acquire(boardnum, numblocks=1)\n\nPrime the board to acquire numblocks blocks and wait for trigger. If no trigger was set up, the board will start acquiring immediately.\n\nNote that this function requires the board to have been set up with the setup_board function.\n\nExamples\n\njulia> boardnum = 2\njulia> numblocks = 32 # acquire 32 1MB blocks\njulia> setup_acquire(boardnum,numblocks)\n\n\n\n\n\n","category":"function"},{"location":"api/wrapper.html#AcqSynth.setup_board-Tuple{Int64}","page":"Low-Level API","title":"AcqSynth.setup_board","text":"setup_board(boardnum)\n\nRead from ultra_config.dat, initialize and calibrate the board. Should be called to set the board to a known state at the beginning of an application.\n\nNote: Call clear_setupdone_bit before calling setup_board to force a full calibration and setup. The first time the board is operated, the setupDone bit is false, and the board undergoes a complete calibration when setup_board is called. Subsequently, only mimimal configuration is performed.\n\nAlso note that the DLL function requires the ultra_config.dat file to be in the working directory when it is executed.\n\n\n\n\n\n","category":"method"},{"location":"api/helpers.html#High-Level-API","page":"High-Level API","title":"High-Level API","text":"","category":"section"},{"location":"api/helpers.html","page":"High-Level API","title":"High-Level API","text":"Modules = [AcqSynth]\nPages   = [\"helpers.jl\"]\nOrder   = [:function]\nPrivate = true","category":"page"},{"location":"index.html#AcqSynth.jl-Documentation","page":"Home","title":"AcqSynth.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Julia interface to Ultraview PCIe Data Acquisition Boards","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Currently, this package only works on Windows due to its dependence on the Windows DLL.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"First, clone the pacakge:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pkg.clone(\"https://github.com/jebej/AcqSynth.jl\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Then, download the Ultraview Windows software (AD12_16-May31_17_r2_64bit.zip or later), and copy AcqSynth.dll, get_usercode.svf, and ultra_config.dat to the deps directory of the package. These three files may be found in the complete_daq_utilities\\Command_Line_Utilities folder in the zip file.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note that the 2012 Visual C++ Redistributable is required, and you should have properly installed the board driver.","category":"page"},{"location":"index.html#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"For now, see the examples.","category":"page"},{"location":"index.html#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Contributions are highly welcomed! Please see the repository on Github and feel free to open issues if you find a bug or if you feel a feature is missing.","category":"page"},{"location":"index.html#Author","page":"Home","title":"Author","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This package was written by Jérémy Béjanin. If you find it useful, drop me a line!","category":"page"}]
}
